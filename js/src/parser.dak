(const single ["(" ")" "[" "]" "{" "}" "@" "#"])
(const whitespace [" " "\r" "\n" "\t"])

(macro doto [v ...forms]
  '(let [vS ,v
  fS (.map forms
              (fn [f]
                (if (array? f)
                  (do
                    (.splice f 1 0 vS)
                    f)
                  '(,f vS))))]
    ...,fS
     vS))
(doto [] (.push 1))

(fn err [expected offset]
  (str "expected " expected " at position " offset))

(fn read-string [input len start]
  (let [lines 0]
    (for [end start len]
      (case (. input end)
        "\"" (return [(input.substring start end) (inc end) lines])
        "\n" (set lines (inc lines)))))
  (throw (Error. "unterminated string")))

(fn read-symbol [input len start expected]
  (when (= start len)
    (throw (Error. (err expected start))))
  (let [end start]
    (while (< end len)
      (let [c (. input end)]
        (if (or (single.includes c) (whitespace.includes c))
          (break)))
      (++ end))
    [(input.substring start end) end]))

(fn read-eol [input len start]
  (let [end start]
    (while (< end len)
      (if (= (. input end) "\n")
        (break)))
    [(input.substring start end) end]))

(fn pos-default [] [0 0 0])

(fn pos-inc [[offset line column] l]
  [(+ offset l) line (+ column l)])

(fn pos-nl [[offset line column]]
  [(inc offset) (inc line) 0])

(fn pos-mv-end [[offset line column] end delta-lines]
  [end (+ line delta-lines) (if (pos? delta-lines) 0 (+ end offset))])

(fn* tokens [input]
  (loop [pos (pos-default)] :when (< pos.offset input.len)
    (let [c (. input offset)]
      (if (= c "\n")
          (pos-nl pos)

          (whitespace.includes c)
          (pos-inc pos)

          (single.includes c)
          (do
            (yield {:kind c :pos pos})
            (pos-inc pos))

          (= c "\"")
          (let [[value end delta-lines] (read-string input len (inc offset))]
            (yield {:kind :string :value value :pos pos})
            (pos-mv-end pos end delta-lines)) ; TODO column doesn't move correctly

          (= c ";")
          (let [[value end] (read-eol input len (inc offset))]
            (yield {:keyword :keyword :value value :pos pos})
            (pos-mv-end pos end 1))

          (= c ":")
          (let [[value end] (read-symbol input len (inc offset) :keyword)]
            (yield {:keyword :keyword :value value :pos pos})
            (pos-mv-end pos end 0))

          (let [[value end] (read-symbol input len (inc offset) :symbol)]
            (yield {:keyword :symbol :value value :pos pos})
            (pos-mv-end pos end 0))))))
