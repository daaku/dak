(import ["https://unpkg.com/prettier@2.7.1/esm/standalone.mjs" prettier]
        ["https://unpkg.com/prettier@2.7.1/esm/parser-babel.mjs" parserBabel]
        ["@daklang/transpiler" [transpileStr]])

(const auto-eval (document.getElementById :auto-eval))
(const fmt (document.getElementById :fmt))
(const dak-code (document.getElementById :dak-code))
(const js-code (document.getElementById :js-code))
(const output (document.getElementById :output))

(fn primitive? [v] (or (bigint? v) (= v (Object v))))

(set globalThis.prn
  (fn [...rest]
    (console.log ...rest)
    (for-of [thing rest]
      (let [child (document.createElement :pre)]
        (set child.innerText
          (if (primitive? thing)
            (String thing)
            (JSON.stringify thing)))
        (output.appendChild child)))))

(fn log-err [prefix err]
  (console.error err)
  (let [child (document.createElement :pre)]
    (set child.innerText (str prefix ": " (?? err.message err)))
    (output.appendChild child)))

(fn@ refresh []
  (if globalThis.IS_PRODUCTION
    (console.clear))
  (output.replaceChildren)
  (try
    (let [js (. (transpileStr dak-code.value {:filename "main.dak"}) :code)]
      (when auto-eval.checked
        ((fn@ []
          (try
            @((.constructor (Object.getPrototypeOf (fn@ [])) js))
            (catch e
              (log-err :eval e))))))
      (set js-code.value
        (try
          (case fmt.value
            :pretty (prettier.format js {:parser :babel :plugins [parserBabel]})
            :minify (. @(Terser.minify js) :code)
            js)
          (catch e
            (log-err fmt.value e)
            js))))
    (catch e
      (log-err fmt.value e))))

(set auto-eval.onchange refresh)
(set dak-code.oninput refresh)
(set fmt.onchange refresh)
(refresh)

(when (not globalThis.IS_PRODUCTION)
  (let token null)
  (fn@ monitor []
    (doto (WebSocket. (str "ws://" location.host "/ws"))
      (.addEventListener :error #(setTimeout monitor 100))
      (.addEventListener :close #(setTimeout monitor 100))
      (.addEventListener :message
        (fn [event]
          (if (null? token) (set token event.data)
              (not= token event.data) (location.reload))))))
  (monitor))
