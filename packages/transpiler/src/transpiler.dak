(fn* transpileNodeList [ctx node assign hoist evKind]
  (let [call (. node 0 :value)
        binding (ctx.bindings.get call)]
    (when (true? binding)
      (yield* (transpileSpecialCall ctx node assign hoist evKind))
      (return))
    (when binding
      (yield* (binding ctx node assign hoist evKind))
      (return))
    (when-let [macro (ctx.macros.get call)]
      (yield* (transpileNodeUnknown ctx (macro ...node) assign hoist evKind))
      (return)))
  (yield* (transpileSpecialCall ctx node assign hoist evKind)))

(fn* transpileBuiltinTypeof [ctx node assign hoist _evKind]
  (yield "typeof ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinInstanceof [ctx node assign hoist _evKind]
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr))
  (yield " instanceof ")
  (yield* (transpileNodeExpr ctx (. node 2) assign hoist evExpr)))

(fn* transpileBuiltinDelete [ctx node assign hoist _evKind]
  (yield "delete ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinSet [ctx node assign hoist _evKind]
  (yield*
    (transpileNodeExpr ctx (. node 2)
      [(... (transpileNodeExpr ctx (. node 1) assign hoist evExpr)) "="]
      hoist evExpr)))

(const builtins
  {:import transpileBuiltinImport
   :const transpileBuiltinConst
   :var transpileBuiltinDef
   :fn transpileBuiltinFnArrow
   "fn@" transpileBuiltinFnArrowAsync
   "fn*" transpileBuiltinFnGenerator
   "fn@*" transpileBuiltinFnAsyncGenerator
   :str (makeOpTranspiler "+")
   "+" (makeOpTranspiler "+" true)
   "-" (makeOpTranspiler "-" true)
   "*" (makeOpTranspiler "*")
   "/" (makeOpTranspiler "/")
   "**" (makeOpTranspiler "**")
   "%" (makeOpTranspiler "%")
   "+=" (makeOpTranspiler "+=")
   "-=" (makeOpTranspiler "-=")
   "&=" (makeOpTranspiler "&=")
   "|=" (makeOpTranspiler "|=")
   "/=" (makeOpTranspiler "/=")
   "*=" (makeOpTranspiler "*=")
   "**=" (makeOpTranspiler "**=")
   "<<=" (makeOpTranspiler "<<=")
   ">>=" (makeOpTranspiler ">>=")
   ">>>=" (makeOpTranspiler ">>>=")
   "||=" (makeOpTranspiler "||=")
   "??=" (makeOpTranspiler "??=")
   "%=" (makeOpTranspiler "%=")
   "??" (makeOpTranspiler "??")
   "<<" (makeOpTranspiler "<<")
   ">>" (makeOpTranspiler ">>")
   ">>>" (makeOpTranspiler ">>>")
   "++" (makeSuffixOpTranspiler "++")
   "--" (makeSuffixOpTranspiler "--")
   :bit-and (makeOpTranspiler "&")
   :bit-or (makeOpTranspiler "|")
   :bit-not (makePrefixOpTranspiler "~")
   :bit-xor (makeOpTranspiler "^")
   "||" (makeOpTranspiler "||")
   :or (makeOpTranspiler "||")
   "&&" (makeOpTranspiler "&&")
   :and (makeOpTranspiler "&&")
   :not (makePrefixOpTranspiler "!")
   :in (makeOpTranspiler " in ")
   "=" transpileBuiltinCmp
   "==" transpileBuiltinCmp
   "!=" transpileBuiltinCmp
   "not=" transpileBuiltinCmp
   "<" transpileBuiltinCmp
   ">" transpileBuiltinCmp
   "<=" transpileBuiltinCmp
   ">=" transpileBuiltinCmp
   :let transpileBuiltinLet
   :throw transpileBuiltinKeywordStatement
   :return transpileBuiltinKeywordStatement
   :yield transpileBuiltinKeywordExpr
   "yield*" transpileBuiltinKeywordExpr
   :break transpileBuiltinKeywordStatement
   :continue transpileBuiltinKeywordStatement
   :await transpileBuiltinKeywordExpr
   :for transpileBuiltinFor
   "for@" transpileBuiltinForAwait
   "for-of" transpileBuiltinForOf
   "for-in" transpileBuiltinForIn
   :case transpileBuiltinCase
   :do transpileBuiltinDo
   :if transpileBuiltinIf
   :while transpileBuiltinWhile
   "." transpileBuiltinDot
   "?." transpileBuiltinQuestionDot
   "..." transpileBuiltinRest
   :typeof transpileBuiltinTypeof
   :instanceof transpileBuiltinInstanceof
   :set transpileBuiltinSet
   :delete transpileBuiltinDelete
   :hash transpileBuiltinHash
   :quote transpileBuiltinQuote
   :macro transpileSpecialMacro
   :try transpileBuiltinTry
   :class transpileBuiltinClass})

(let macros {})

(fn newCtx [config macros]
  (let gensym 0)
  {...config
   :bindings (bindings builtins)
   :macros (bindings macros)
   :gensym (fn [prefix]
              (set prefix (?? prefix "gensym"))
              {:kind :symbol :value `${prefix}__${(++ gensym)}` :pos {}})})

(set macros
  ((fn []
    (let [ctx (newCtx {} {})
          input (uninterrupt (tokens ctx builtinMacros))]
      (while true
        (if-let [node (astOne ctx input)]
          [(... (transpileNodeStatement ctx node null null evStat))]
          (return (. ctx.macros.scopes 0))))))))

(fn* transpileCtx [code ctx semi]
  (let [input (uninterrupt (tokens ctx code))]
    (set semi (?? semi true))
    (while true
      (if-let [node (astOne ctx input)]
        (do
          (yield* (transpileNodeStatement ctx node null null evStat))
          (when semi
            (yield ";")))
        (return)))))

(fn* ^:export transpile [code config]
  (yield* (transpileCtx code (newCtx (or config {}) macros))))

(fn ^:export transpileStr [code config]
  (set config (?? config {}))
  (let [source (?? config.filename "<anonymous>")
        parts []
        map (SourceMapGenerator.)
        column 0]
    (for-of [out (transpile code config)]
      (let [[part partToken] (if (string? out) [out] out)]
        (when (number? partToken?.pos?.line)
          (map.addMapping
            {:source source
             :original {:line (inc partToken.pos.line)
                        :column partToken.pos.column}
             :generated {:line 1 :column column}
             :name (if (and (= partToken.kind :symbol)
                            (not (partToken.value.includes ".")))
                      (mangleSym partToken.value)
                      null)}))
        (+= column part.length)
        (parts.push part)))
    (map.setSourceContent source code)
    (let [mapJSON (map.toJSON)]
      (when (= config.sourcemap :inline)
        (parts.push "\n//# sourceMappingURL=data:application/json;base64,"
                    (btoa (JSON.stringify mapJSON))))
      {:code (parts.join "") :map mapJSON})))
