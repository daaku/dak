(fn* transpileBuiltinHash [ctx node assign hoist evKind]
  (if (= (. node 1 :kind) :list)
    (yield* (transpileHashLambda ctx node assign hoist evKind))
    (throw (err ctx ctx `unexpected hash "${(. node 1 :kind)}"`))))

(fn* serializeNode [ctx node hoist]
  (if (Array.isArray node)
    (if (= (?. node 0 :value) :unquote)
      (yield* (transpileNodeExpr ctx (. node 1) null hoist evExpr))
      (do
        (yield "Object.defineProperties([")
        (for-of [i node]
          (yield* (serializeNode ctx i hoist))
          (yield ","))
        (yield "],")
        (yield (JSON.stringify
                 {:kind {:value node.kind :enumerable false}
                  :pos {:value node.pos :enumerable false}}))
        (yield ")")))
    (yield (JSON.stringify node))))

(fn applyGensym [ctx existing node]
  (if (Array.isArray node)
      (node.forEach #(applyGensym ctx existing $))
      (and (= node.kind :symbol) (node.value.endsWith "#"))
      (if-let [found (. existing node.value)]
        (set node.value found)
        (let [gen (. (ctx.gensym :macro) :value)]
          (set (. existing node.value) gen)
          (set node.value gen)))))

(fn* transpileBuiltinQuote [ctx node assign hoist _evKind]
  (applyGensym ctx {} node)
  (yield* (transpileSpecialAssign ctx assign))
  (yield* (serializeNode ctx (. node 1) hoist)))

(fn* transpileSpecialMacro [ctx node]
  (let [args (-> node (. 2) (.map #(partsStr (transpileSpecialDestructure ctx $))))
        body (partsStr (transpileSpecialBody ctx (node.slice 3) "return "))]
    ; (when (= (?. node 1 :value) :deftest)
    ;   (console.log body))
    (ctx.macros.add (. node 1 :value) (Function. :_macroName ...args body))))

; function, method or constructor call
(fn* transpileSpecialCall [ctx node assign hoist evKind]
  (yield* (transpileSpecialAssign ctx assign))
  (let [argStart 1]
    (if (= (. node 0 :kind) :symbol)
      (let [call (. node 0 :value)]
        (if (call.endsWith ".")
            (do
              (yield ["new " (. node 0)])
              (yield [(mangleSym (call.slice 0 -1)) (. node 0)])) ; drop the trailing .
            (call.startsWith ".")
            (do
              (yield* (transpileNodeExpr ctx (. node 1) null hoist evExpr))
              (yield [(mangleSym call) (. node 0)])
              (set argStart 2))
            (yield [(mangleSym call) node])))
      (yield* (transpileNodeExpr ctx (. node 0) null hoist evExpr)))
    (let [comma (splitter ",")]
      (yield "(")
      (for [i argStart node.length]
        (yield (comma))
        (yield* (transpileNodeExpr ctx (. node i) null hoist evExpr)))
      (yield ")"))))

(fn* transpileNodeList [ctx node assign hoist evKind]
  (let [call (. node 0 :value)
        binding (ctx.bindings.get call)]
    (when (true? binding)
      (yield* (transpileSpecialCall ctx node assign hoist evKind))
      (return))
    (when binding
      (yield* (binding ctx node assign hoist evKind))
      (return))
    (when-let [macro (ctx.macros.get call)]
      (yield* (transpileNodeUnknown ctx (macro ...node) assign hoist evKind))
      (return)))
  (yield* (transpileSpecialCall ctx node assign hoist evKind)))

(fn* transpileBuiltinTypeof [ctx node assign hoist _evKind]
  (yield "typeof ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinInstanceof [ctx node assign hoist _evKind]
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr))
  (yield " instanceof ")
  (yield* (transpileNodeExpr ctx (. node 2) assign hoist evExpr)))

(fn* transpileBuiltinDelete [ctx node assign hoist _evKind]
  (yield "delete ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinSet [ctx node assign hoist _evKind]
  (yield*
    (transpileNodeExpr ctx (. node 2)
      [(... (transpileNodeExpr ctx (. node 1) assign hoist evExpr)) "="]
      hoist evExpr)))

(const builtins
  {:import transpileBuiltinImport
   :const transpileBuiltinConst
   :var transpileBuiltinDef
   :fn transpileBuiltinFnArrow
   "fn@" transpileBuiltinFnArrowAsync
   "fn*" transpileBuiltinFnGenerator
   "fn@*" transpileBuiltinFnAsyncGenerator
   :str (makeOpTranspiler "+")
   "+" (makeOpTranspiler "+" true)
   "-" (makeOpTranspiler "-" true)
   "*" (makeOpTranspiler "*")
   "/" (makeOpTranspiler "/")
   "**" (makeOpTranspiler "**")
   "%" (makeOpTranspiler "%")
   "+=" (makeOpTranspiler "+=")
   "-=" (makeOpTranspiler "-=")
   "&=" (makeOpTranspiler "&=")
   "|=" (makeOpTranspiler "|=")
   "/=" (makeOpTranspiler "/=")
   "*=" (makeOpTranspiler "*=")
   "**=" (makeOpTranspiler "**=")
   "<<=" (makeOpTranspiler "<<=")
   ">>=" (makeOpTranspiler ">>=")
   ">>>=" (makeOpTranspiler ">>>=")
   "||=" (makeOpTranspiler "||=")
   "??=" (makeOpTranspiler "??=")
   "%=" (makeOpTranspiler "%=")
   "??" (makeOpTranspiler "??")
   "<<" (makeOpTranspiler "<<")
   ">>" (makeOpTranspiler ">>")
   ">>>" (makeOpTranspiler ">>>")
   "++" (makeSuffixOpTranspiler "++")
   "--" (makeSuffixOpTranspiler "--")
   :bit-and (makeOpTranspiler "&")
   :bit-or (makeOpTranspiler "|")
   :bit-not (makePrefixOpTranspiler "~")
   :bit-xor (makeOpTranspiler "^")
   "||" (makeOpTranspiler "||")
   :or (makeOpTranspiler "||")
   "&&" (makeOpTranspiler "&&")
   :and (makeOpTranspiler "&&")
   :not (makePrefixOpTranspiler "!")
   :in (makeOpTranspiler " in ")
   "=" transpileBuiltinCmp
   "==" transpileBuiltinCmp
   "!=" transpileBuiltinCmp
   "not=" transpileBuiltinCmp
   "<" transpileBuiltinCmp
   ">" transpileBuiltinCmp
   "<=" transpileBuiltinCmp
   ">=" transpileBuiltinCmp
   :let transpileBuiltinLet
   :throw transpileBuiltinKeywordStatement
   :return transpileBuiltinKeywordStatement
   :yield transpileBuiltinKeywordExpr
   "yield*" transpileBuiltinKeywordExpr
   :break transpileBuiltinKeywordStatement
   :continue transpileBuiltinKeywordStatement
   :await transpileBuiltinKeywordExpr
   :for transpileBuiltinFor
   "for@" transpileBuiltinForAwait
   "for-of" transpileBuiltinForOf
   "for-in" transpileBuiltinForIn
   :case transpileBuiltinCase
   :do transpileBuiltinDo
   :if transpileBuiltinIf
   :while transpileBuiltinWhile
   "." transpileBuiltinDot
   "?." transpileBuiltinQuestionDot
   "..." transpileBuiltinRest
   :typeof transpileBuiltinTypeof
   :instanceof transpileBuiltinInstanceof
   :set transpileBuiltinSet
   :delete transpileBuiltinDelete
   :hash transpileBuiltinHash
   :quote transpileBuiltinQuote
   :macro transpileSpecialMacro
   :try transpileBuiltinTry
   :class transpileBuiltinClass})

(let macros {})

(fn newCtx [config macros]
  (let gensym 0)
  {...config
   :bindings (bindings builtins)
   :macros (bindings macros)
   :gensym (fn [prefix]
              (set prefix (?? prefix "gensym"))
              {:kind :symbol :value `${prefix}__${(++ gensym)}` :pos {}})})

(set macros
  ((fn []
    (let [ctx (newCtx {} {})
          input (uninterrupt (tokens ctx builtinMacros))]
      (while true
        (if-let [node (astOne ctx input)]
          [(... (transpileNodeStatement ctx node null null evStat))]
          (return (. ctx.macros.scopes 0))))))))

(fn* transpileCtx [code ctx semi]
  (let [input (uninterrupt (tokens ctx code))]
    (set semi (?? semi true))
    (while true
      (if-let [node (astOne ctx input)]
        (do
          (yield* (transpileNodeStatement ctx node null null evStat))
          (when semi
            (yield ";")))
        (return)))))

(fn* ^:export transpile [code config]
  (yield* (transpileCtx code (newCtx (or config {}) macros))))

(fn ^:export transpileStr [code config]
  (set config (?? config {}))
  (let [source (?? config.filename "<anonymous>")
        parts []
        map (SourceMapGenerator.)
        column 0]
    (for-of [out (transpile code config)]
      (let [[part partToken] (if (string? out) [out] out)]
        (when (number? partToken?.pos?.line)
          (map.addMapping
            {:source source
             :original {:line (inc partToken.pos.line)
                        :column partToken.pos.column}
             :generated {:line 1 :column column}
             :name (if (and (= partToken.kind :symbol)
                            (not (partToken.value.includes ".")))
                      (mangleSym partToken.value)
                      null)}))
        (+= column part.length)
        (parts.push part)))
    (map.setSourceContent source code)
    (let [mapJSON (map.toJSON)]
      (when (= config.sourcemap :inline)
        (parts.push "\n//# sourceMappingURL=data:application/json;base64,"
                    (btoa (JSON.stringify mapJSON))))
      {:code (parts.join "") :map mapJSON})))
