(fn* transpileClassLet [ctx node _assign _hoist]
  (let [index 1
        stic false]
    (when (= (. node index :value) "^:static")
      (set stic true)
      (yield "static ")
      (++ index))
    ; (let [#one #two three]) style
    (when (= (. node index :kind) :array)
      (let [count (. node index :length)]
        (for-of [sym (. node index)]
          (yield* (transpileClassPrivateSymbol ctx sym))
          (yield ";")
          (-- count)
          (when (and stic (pos? count))
            (yield "static "))))
      (return))
    (yield* (transpileClassPrivateSymbol ctx (. node index)))
    (++ index)
    (when (. node index)
      (yield "=")
      (yield* (transpileNodeExpr ctx (. node index) null null evExpr)))
    (yield ";")))

(fn makeClassFnTranspiler [pre]
  (fn* [ctx node]
    (yield [pre node])
    (yield* (transpileClassPrivateSymbol ctx (. node 1)))
    (yield* (transpileSpecialFnArgs ctx (. node 2)))
    (yield "{")
    (yield* (transpileSpecialBody ctx (node.slice 3) "return " null evStat))
    (yield "}")))

(const transpileClassFnArrow (makeClassFnTranspiler ""))
(const transpileClassFnArrowAsync (makeClassFnTranspiler "async "))
(const transpileClassFnGenerator (makeClassFnTranspiler "*"))
(const transpileClassFnAsyncGenerator (makeClassFnTranspiler "async *"))

(const classBuiltins {:let transpileClassLet
                      :fn transpileClassFnArrow
                      "fn@" transpileClassFnArrowAsync
                      "fn*" transpileClassFnGenerator
                      "fn@*" transpileClassFnAsyncGenerator
                      :static transpileClassStatic})

(fn* transpileClassNodeList [ctx node assign hoist evKind]
  (let [call (. node 0 :value)]
    (when-let [builtin (. classBuiltins call)]
      (yield* (builtin ctx node assign hoist evKind))
      (return))
    (when-let [macro (ctx.macros.get call)]
      (yield* (transpileClassNodeList ctx (macro ...node) assign hoist evKind))
      (return)))
  (throw (err ctx (. node 0) `unexpected class body "${(. node 0 :kind)}"`)))

(fn* transpileBuiltinClass [ctx node assign hoist evKind]
  (yield* (transpileSpecialAssign ctx assign))
  (let [[prefix index] (exportDefault ctx node)]
    (yield* prefix)
    (yield [:class (. node 0)])
    ; named
    (when (= (?. node index :kind) :symbol)
      (yield " ")
      (yield* (transpileNodeSymbol ctx (. node index)))
      (ctx.bindings.add (. node index :value))
      (++ index))
    (when (and (= (?. node index :kind) :string) (= (?. node index :value) :extends))
      (yield [" extends " (. node index)])
      (yield* (transpileNodeExpr ctx (. node (inc index)) null hoist evExpr))
      (+= index 2))
    (yield "{")
    (for [i index node.length]
      (yield* (transpileClassNodeList ctx (. node i) null null evStat)))
    (yield "}")))

(fn hashLambdaArgMap [ctx args n]
  (if (and (Array.isArray n) (not= (?. n 0 :value) :hash))
      (do
        (n.forEach #(hashLambdaArgMap ctx args $))
        (return))
      (not= n.kind :symbol)
      (return)
      (n.value.startsWith "...$")
      (do
        (when (not args.rest)
          (set args.rest (ctx.gensym :lambda_rest)))
        (set n.value `${args.rest.value}${(n.value.slice 4)}`)
        (return))
      (not (n.value.startsWith "$"))
      (return))

  ; check if we have a dot, indicates we're replacing part of a symbol
  ; like $2.replace
  (let [sym n.value
        dot (sym.indexOf ".")
        target (if (neg? dot) sym (sym.slice 0 dot))
        arg 0]
    (when (not= target "$")
      (set arg (dec (parseInt (target.slice 1) 10))))
    (for [i 0 (inc arg)]
      (when (not (. args i))
        (set (. args i) (ctx.gensym :lambda))))
    (let [replace (. args arg :value)]
      (set n.value (if (neg? dot) replace `${replace}${(sym.slice dot)}`)))))

(fn* transpileHashLambda [ctx node assign hoist evKind]
  (yield* (transpileSpecialAssign ctx assign))
  (let [args []
        comma (splitter ",")]
    (hashLambdaArgMap ctx args (. node 1))
    (yield "((")
    (for-of [arg args]
      (yield (comma))
      (yield* (transpileNodeSymbol ctx arg)))
    (when args.rest
      (yield (comma))
      (yield "...")
      (yield* (transpileNodeSymbol ctx args.rest)))
    (yield ")=>{")
    (yield* (transpileNodeStatement ctx (. node 1) "return " hoist evStat))
    (yield "})")))

(fn* transpileBuiltinHash [ctx node assign hoist evKind]
  (if (= (. node 1 :kind) :list)
    (yield* (transpileHashLambda ctx node assign hoist evKind))
    (throw (err ctx ctx `unexpected hash "${(. node 1 :kind)}"`))))

(fn* serializeNode [ctx node hoist]
  (if (Array.isArray node)
    (if (= (?. node 0 :value) :unquote)
      (yield* (transpileNodeExpr ctx (. node 1) null hoist evExpr))
      (do
        (yield "Object.defineProperties([")
        (for-of [i node]
          (yield* (serializeNode ctx i hoist))
          (yield ","))
        (yield "],")
        (yield (JSON.stringify
                 {:kind {:value node.kind :enumerable false}
                  :pos {:value node.pos :enumerable false}}))
        (yield ")")))
    (yield (JSON.stringify node))))

(fn applyGensym [ctx existing node]
  (if (Array.isArray node)
      (node.forEach #(applyGensym ctx existing $))
      (and (= node.kind :symbol) (node.value.endsWith "#"))
      (if-let [found (. existing node.value)]
        (set node.value found)
        (let [gen (. (ctx.gensym :macro) :value)]
          (set (. existing node.value) gen)
          (set node.value gen)))))

(fn* transpileBuiltinQuote [ctx node assign hoist _evKind]
  (applyGensym ctx {} node)
  (yield* (transpileSpecialAssign ctx assign))
  (yield* (serializeNode ctx (. node 1) hoist)))

(fn* transpileSpecialMacro [ctx node]
  (let [args (-> node (. 2) (.map #(partsStr (transpileSpecialDestructure ctx $))))
        body (partsStr (transpileSpecialBody ctx (node.slice 3) "return "))]
    ; (when (= (?. node 1 :value) :deftest)
    ;   (console.log body))
    (ctx.macros.add (. node 1 :value) (Function. :_macroName ...args body))))

; function, method or constructor call
(fn* transpileSpecialCall [ctx node assign hoist evKind]
  (yield* (transpileSpecialAssign ctx assign))
  (let [argStart 1]
    (if (= (. node 0 :kind) :symbol)
      (let [call (. node 0 :value)]
        (if (call.endsWith ".")
            (do
              (yield ["new " (. node 0)])
              (yield [(mangleSym (call.slice 0 -1)) (. node 0)])) ; drop the trailing .
            (call.startsWith ".")
            (do
              (yield* (transpileNodeExpr ctx (. node 1) null hoist evExpr))
              (yield [(mangleSym call) (. node 0)])
              (set argStart 2))
            (yield [(mangleSym call) node])))
      (yield* (transpileNodeExpr ctx (. node 0) null hoist evExpr)))
    (let [comma (splitter ",")]
      (yield "(")
      (for [i argStart node.length]
        (yield (comma))
        (yield* (transpileNodeExpr ctx (. node i) null hoist evExpr)))
      (yield ")"))))

(fn* transpileNodeList [ctx node assign hoist evKind]
  (let [call (. node 0 :value)
        binding (ctx.bindings.get call)]
    (when (true? binding)
      (yield* (transpileSpecialCall ctx node assign hoist evKind))
      (return))
    (when binding
      (yield* (binding ctx node assign hoist evKind))
      (return))
    (when-let [macro (ctx.macros.get call)]
      (yield* (transpileNodeUnknown ctx (macro ...node) assign hoist evKind))
      (return)))
  (yield* (transpileSpecialCall ctx node assign hoist evKind)))

(fn* transpileBuiltinTypeof [ctx node assign hoist _evKind]
  (yield "typeof ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinInstanceof [ctx node assign hoist _evKind]
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr))
  (yield " instanceof ")
  (yield* (transpileNodeExpr ctx (. node 2) assign hoist evExpr)))

(fn* transpileBuiltinDelete [ctx node assign hoist _evKind]
  (yield "delete ")
  (yield* (transpileNodeExpr ctx (. node 1) assign hoist evExpr)))

(fn* transpileBuiltinSet [ctx node assign hoist _evKind]
  (yield*
    (transpileNodeExpr ctx (. node 2)
      [(... (transpileNodeExpr ctx (. node 1) assign hoist evExpr)) "="]
      hoist evExpr)))

(const builtins
  {:import transpileBuiltinImport
   :const transpileBuiltinConst
   :var transpileBuiltinDef
   :fn transpileBuiltinFnArrow
   "fn@" transpileBuiltinFnArrowAsync
   "fn*" transpileBuiltinFnGenerator
   "fn@*" transpileBuiltinFnAsyncGenerator
   :str (makeOpTranspiler "+")
   "+" (makeOpTranspiler "+" true)
   "-" (makeOpTranspiler "-" true)
   "*" (makeOpTranspiler "*")
   "/" (makeOpTranspiler "/")
   "**" (makeOpTranspiler "**")
   "%" (makeOpTranspiler "%")
   "+=" (makeOpTranspiler "+=")
   "-=" (makeOpTranspiler "-=")
   "&=" (makeOpTranspiler "&=")
   "|=" (makeOpTranspiler "|=")
   "/=" (makeOpTranspiler "/=")
   "*=" (makeOpTranspiler "*=")
   "**=" (makeOpTranspiler "**=")
   "<<=" (makeOpTranspiler "<<=")
   ">>=" (makeOpTranspiler ">>=")
   ">>>=" (makeOpTranspiler ">>>=")
   "||=" (makeOpTranspiler "||=")
   "??=" (makeOpTranspiler "??=")
   "%=" (makeOpTranspiler "%=")
   "??" (makeOpTranspiler "??")
   "<<" (makeOpTranspiler "<<")
   ">>" (makeOpTranspiler ">>")
   ">>>" (makeOpTranspiler ">>>")
   "++" (makeSuffixOpTranspiler "++")
   "--" (makeSuffixOpTranspiler "--")
   :bit-and (makeOpTranspiler "&")
   :bit-or (makeOpTranspiler "|")
   :bit-not (makePrefixOpTranspiler "~")
   :bit-xor (makeOpTranspiler "^")
   "||" (makeOpTranspiler "||")
   :or (makeOpTranspiler "||")
   "&&" (makeOpTranspiler "&&")
   :and (makeOpTranspiler "&&")
   :not (makePrefixOpTranspiler "!")
   :in (makeOpTranspiler " in ")
   "=" transpileBuiltinCmp
   "==" transpileBuiltinCmp
   "!=" transpileBuiltinCmp
   "not=" transpileBuiltinCmp
   "<" transpileBuiltinCmp
   ">" transpileBuiltinCmp
   "<=" transpileBuiltinCmp
   ">=" transpileBuiltinCmp
   :let transpileBuiltinLet
   :throw transpileBuiltinKeywordStatement
   :return transpileBuiltinKeywordStatement
   :yield transpileBuiltinKeywordExpr
   "yield*" transpileBuiltinKeywordExpr
   :break transpileBuiltinKeywordStatement
   :continue transpileBuiltinKeywordStatement
   :await transpileBuiltinKeywordExpr
   :for transpileBuiltinFor
   "for@" transpileBuiltinForAwait
   "for-of" transpileBuiltinForOf
   "for-in" transpileBuiltinForIn
   :case transpileBuiltinCase
   :do transpileBuiltinDo
   :if transpileBuiltinIf
   :while transpileBuiltinWhile
   "." transpileBuiltinDot
   "?." transpileBuiltinQuestionDot
   "..." transpileBuiltinRest
   :typeof transpileBuiltinTypeof
   :instanceof transpileBuiltinInstanceof
   :set transpileBuiltinSet
   :delete transpileBuiltinDelete
   :hash transpileBuiltinHash
   :quote transpileBuiltinQuote
   :macro transpileSpecialMacro
   :try transpileBuiltinTry
   :class transpileBuiltinClass})

(let macros {})

(fn newCtx [config macros]
  (let gensym 0)
  {...config
   :bindings (bindings builtins)
   :macros (bindings macros)
   :gensym (fn [prefix]
              (set prefix (?? prefix "gensym"))
              {:kind :symbol :value `${prefix}__${(++ gensym)}` :pos {}})})

(set macros
  ((fn []
    (let [ctx (newCtx {} {})
          input (uninterrupt (tokens ctx builtinMacros))]
      (while true
        (if-let [node (astOne ctx input)]
          [(... (transpileNodeStatement ctx node null null evStat))]
          (return (. ctx.macros.scopes 0))))))))

(fn* transpileCtx [code ctx semi]
  (let [input (uninterrupt (tokens ctx code))]
    (set semi (?? semi true))
    (while true
      (if-let [node (astOne ctx input)]
        (do
          (yield* (transpileNodeStatement ctx node null null evStat))
          (when semi
            (yield ";")))
        (return)))))

(fn* ^:export transpile [code config]
  (yield* (transpileCtx code (newCtx (or config {}) macros))))

(fn ^:export transpileStr [code config]
  (set config (?? config {}))
  (let [source (?? config.filename "<anonymous>")
        parts []
        map (SourceMapGenerator.)
        column 0]
    (for-of [out (transpile code config)]
      (let [[part partToken] (if (string? out) [out] out)]
        (when (number? partToken?.pos?.line)
          (map.addMapping
            {:source source
             :original {:line (inc partToken.pos.line)
                        :column partToken.pos.column}
             :generated {:line 1 :column column}
             :name (if (and (= partToken.kind :symbol)
                            (not (partToken.value.includes ".")))
                      (mangleSym partToken.value)
                      null)}))
        (+= column part.length)
        (parts.push part)))
    (map.setSourceContent source code)
    (let [mapJSON (map.toJSON)]
      (when (= config.sourcemap :inline)
        (parts.push "\n//# sourceMappingURL=data:application/json;base64,"
                    (btoa (JSON.stringify mapJSON))))
      {:code (parts.join "") :map mapJSON})))
